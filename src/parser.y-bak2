%code top{
    #include <iostream>
    #include <assert.h>
    #include "parser.h"
    #include "SymbolTable.h" // 导入符号表类
    #include "Type.h" // 导入类型类
    #include "Ast.h" // 导入抽象语法树的节点类
    extern Ast ast; // 声明抽象语法树
    int yylex();
    int yyerror( char const * );
}

%code requires {
    #include "Ast.h"
    #include "SymbolTable.h"
    #include "Type.h"
}

%union {
    int itype;
    char* strtype;
    StmtNode* stmttype;
    ExprNode* exprtype;
    Type* type;
}

%start Program
// 定义终结符
%token <strtype> ID 
%token <itype> INTEGER
%token IF ELSE
%token INT VOID
%token LPAREN RPAREN LBRACE RBRACE SEMICOLON
%token ADD SUB OR AND LESS ASSIGN
%token RETURN

// 定义非终结符
%nterm <stmttype> Stmts Stmt AssignStmt IfStmt ReturnStmt DeclStmt
%nterm <exprtype> Exp AddExp Cond LOrExp PrimaryExp LVal RelExp LAndExp
%nterm <type> Type

// 定义优先级
%precedence THEN
%precedence ELSE

%%
// 定义程序的语法规则，Program是文法的开始符号
Program
    /* 程序的语法规则：
     * 文法：
     * Program -> Stmts
     * 语义动作：
     * - ast.setRoot($1)：将语句序列节点设为AST根节点
     * - $1：访问第一个产生式符号Stmts生成的节点
     * 原因：建立程序的顶层结构，初始化AST
     */
    : Stmts { 
        ast.setRoot($1); 
    }
    ;

// 语句序列
Stmts
    /* 语句序列的语法规则：
     * 文法：
     * Stmts -> Stmts Stmt | Stmt
     * 语义动作：
     * 1. $$ = $1：单语句情况，直接传递节点
     * 2. $$ = new SeqNode($1, $2)：
     *    - $1：访问已有的语句序列节点
     *    - $2：访问新的语句节点
     *    - new SeqNode：创建序列节点连接它们
     * 原因：实现语句的顺序存储和执行
     */
    : Stmts Stmt { $$ = new SeqNode($1, $2); }
    | Stmt { $$ = $1; }
    ;

//语句
Stmt
    /* 语句的语法规则：
     * 文法：
     * Stmt -> AssignStmt | IfStmt | ReturnStmt | DeclStmt | SEMICOLON
     * 语义动作：
     * 1. $$ = $1：传递具体语句节点
     * 2. $$ = nullptr：空语句情况
     * 原因：
     * - 支持多种类型的语句，包括赋值语句、if语句、返回语句、声明语句和空语句
     * - nullptr处理空语句，增加语法健壮性
     */
    : AssignStmt { $$ = $1; }
    | IfStmt { $$ = $1; }
    | ReturnStmt { $$ = $1; }
    | DeclStmt { $$ = $1; }
    | SEMICOLON { $$ = nullptr; }
    ;

// 赋值语句
AssignStmt
    /* 赋值语句的语法规则：
     * 文法：
     * AssignStmt -> LVal ASSIGN Exp SEMICOLON
     * 语义动作：$$ = new AssignStmt($1, $3)
     * - $1：左值表达式节点
     * - $3：右值表达式节点
     * 原因：创建赋值语句节点，连接左值和表达式
     */
    : LVal ASSIGN Exp SEMICOLON {
        $$ = new AssignStmt($1, $3);
    }
    ;

// if语句
IfStmt
    /* 条件语句的语法规则：
     * 文法：
     * IfStmt -> IF LPAREN Cond RPAREN Stmt
     *        | IF LPAREN Cond RPAREN Stmt ELSE Stmt
     * 语义动作：
     * 1. $$ = new IfStmt($3, $5)
     *    - $3：条件表达式节点
     *    - $5：then分支语句节点
     *    - 创建基本if语句节点
     * 2. $$ = new IfElseStmt($3, $5, $7)
     *    - $3：条件表达式节点
     *    - $5：then分支语句节点
     *    - $7：else分支语句节点
     *    - 创建带else的if语句节点
     * 原因：
     * - %prec THEN解决悬空else问题
     * - 分别处理有无else两种情况
     * - 条件、then和else分支形成完整的控制流
     */
    : IF LPAREN Cond RPAREN Stmt %prec THEN {
        $$ = new IfStmt($3, $5);
    }
    | IF LPAREN Cond RPAREN Stmt ELSE Stmt {
        $$ = new IfElseStmt($3, $5, $7);
    }
    ;

// 返回语句
ReturnStmt
    /* 返回语句的语法规则：
     * 文法：
     * ReturnStmt -> RETURN Exp SEMICOLON
     *            | RETURN SEMICOLON
     * 语义动作：
     * 1. $$ = new ReturnStmt($2)
     *    - $2：返回值表达式节点
     *    - 创建带返回值的返回语句节点
     * 2. $$ = new ReturnStmt(nullptr)
     *    - nullptr表示无返回值
     *    - 创建void返回语句节点
     * 原因：
     * - 支持函数返回值
     * - 处理void函数的无返回值返回
     */
    : RETURN Exp SEMICOLON { $$ = new ReturnStmt($2); }
    | RETURN SEMICOLON { $$ = new ReturnStmt(nullptr); }
    ;

// 基本表达式
Exp
    /* 表达式的语法规则：
     * 文法：
     * Exp -> AddExp
     * 语义动作：$$ = $1
     * - $1：加法表达式
     * 原因：
     * - 表达式的基本形式是算术表达式
     * - 算术表达式的基本形式是加法表达式
     */
    : AddExp { $$ = $1; }
    ;

// 条件表达式
Cond
    /* 条件表达式的语法规则：
     * 文法：
     * Cond -> LOrExp
     * 语义动作：$$ = $1
     * - $1：逻辑或表达式节点
     * 原因：
     * - 条件表达式最终归结为逻辑表达式，而逻辑表达式的基本形式是逻辑或表达式
     */
    : LOrExp { $$ = $1; }
    ;

// 初级表达式（不可分割的表达式基本单元）
PrimaryExp
    /* 初级表达式的语法规则：
     * 文法：
     * PrimaryExp -> LPAREN Exp RPAREN
     *            | LVal
     *            | INTEGER
     * 语义动作：
     * 1. $$ = $2：括号表达式，返回内部表达式节点
     * 2. $$ = $1：变量引用，返回左值节点
     * 3. $$ = new Constant(se)：
     *    - 创建常量符号表项
     *    - 包装为常量节点
     * 原因：
     * - 处理基本表达式形式
     * - 支持括号优先级
     * - 处理变量访问和常量
     */
    : LPAREN Exp RPAREN { $$ = $2; }
    | LVal { $$ = $1; }
    | INTEGER {
        SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, $1);
        $$ = new Constant(se);
    }
    ;

// 表达式左值
LVal
    /* 左值表达式的语法规则：
     * 文法：
     * LVal -> ID
     * 
     * 语义动作：
     * 1. identifiers->lookup($1)
     *    - 在符号表中查找标识符
     *    - $1是词法分析器返回的标识符名称
     * 
     * 2. if(se == nullptr)
     *    - 检查变量是否已声明
     *    - 未声明则报错
     * 
     * 3. $$ = new Id(se)
     *    - 创建标识符节点
     *    - 包含符号表项信息
     * 
     * 4. delete []$1
     *    - 释放标识符字符串内存
     *    - 防止内存泄露
     * 
     * 原因：
     * - 实现变量的引用
     * - 确保变量先声明后使用
     * - 维护符号表信息
     * - 支持变量的赋值和使用
     */
    : ID {
        SymbolEntry *se = identifiers->lookup($1);
        if(se == nullptr)
            fprintf(stderr, "ID %s undefined\n", $1);
        $$ = new Id(se);
        delete []$1;
    }
    ;

// 加法表达式
AddExp
    /* 加法表达式的语法规则：
     * 文法：
     * AddExp -> AddExp ADD RelExp
     *        | AddExp SUB RelExp
     *        | RelExp
     * 语义动作：
     * 1. 创建临时符号存储计算结果
     * 2. 构建二元表达式节点
     * 原因：
     * - 需要临时存储算术运算结果
     * - 左递归确保运算符左结合性
     * - 生成正确的指令序列
     */
    : AddExp ADD RelExp {
        SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel());
        $$ = new BinaryExpr(se, BinaryExpr::ADD, $1, $3);
    }
    | AddExp SUB RelExp {
        SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel());
        $$ = new BinaryExpr(se, BinaryExpr::SUB, $1, $3);
    }
    | RelExp { $$ = $1; }
    ;

// 关系表达式
RelExp
    /* 关系表达式的语法规则：
     * 文法：
     * RelExp -> RelExp LESS AddExp
     *        | PrimaryExp
     * 语义动作：
     * 1. $$ = new BinaryExpr(se, BinaryExpr::LESS, $1, $3)
     *    - se：临时符号表项存储比较结果
     *    - BinaryExpr::LESS：小于运算符
     *    - $1, $3：左右操作数
     * 2. $$ = $1：基本项，直接传递算术表达式
     * 原因：
     * - 创建临时变量存储比较结果
     * - 使用bool类型表示比较结果
     * - 关系表达式的基本单元是初级表达式
     * - 关系表达式推导初级表达式可以保证关系运算的优先级低于算术运算
     */
    : RelExp LESS AddExp {
        SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel());
        $$ = new BinaryExpr(se, BinaryExpr::LESS, $1, $3);
    }
    | PrimaryExp { $$ = $1; }
    ;

// 逻辑与表达式
LAndExp
    /* 逻辑与表达式的语法规则：
     * 文法：
     * LAndExp -> LAndExp AND RelExp
     *         | RelExp
     * 语义动作：
     * 1. $$ = new BinaryExpr(se, BinaryExpr::AND, $1, $3)
     *    - se：临时符号表项存储与运算结果
     *    - $1, $3：左右操作数
     * 2. $$ = $1：基本项，直接传递关系表达式
     * 原因：
     * - 支持短路求值
     * - bool类型结果
     * - 左递归保证结合性
     */
    : LAndExp AND RelExp {
        SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel());
        $$ = new BinaryExpr(se, BinaryExpr::AND, $1, $3);
    }
    | RelExp { $$ = $1; }
    ;

// 逻辑或表达式
LOrExp
    /* 逻辑或表达式的语法规则：
     * 文法：
     * LOrExp -> LOrExp OR LAndExp
     *        | LAndExp
     * 语义动作：
     * 1. $$ = new BinaryExpr(se, BinaryExpr::OR, $1, $3)
     *    - se：临时符号表项存储或运算结果
     *    - $1, $3：左右操作数
     * 2. $$ = $1：基本项，传递与表达式
     * 原因：
     * - 支持短路求值
     * - bool类型结果
     * - 优先级低于AND
     */
    : LOrExp OR LAndExp {
        SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel());
        $$ = new BinaryExpr(se, BinaryExpr::OR, $1, $3);
    }
    | LAndExp { $$ = $1; }
    ;

// 类型
Type
    /* 类型的语法规则：
     * 文法：
     * Type -> INT | VOID
     * 语义动作：
     * - $$ = TypeSystem::intType：整型
     * - $$ = TypeSystem::voidType：空类型
     * 原因：
     * - 支持基本数据类型
     * - 用于变量声明和函数返回值
     */
    : INT { $$ = TypeSystem::intType; }
    | VOID { $$ = TypeSystem::voidType; }
    ;

// 声明语句
DeclStmt
    /* 声明语句的语法规则：
     * 文法：
     * DeclStmt -> Type ID SEMICOLON
     * 语义动作：
     * 1. 创建标识符符号表项
     * 2. 添加到符号表
     * 3. 创建声明语句节点
     * 原因：
     * - 管理变量作用域
     * - 记录变量类型信息
     * - 支持变量声明
     */
    : Type ID SEMICOLON {
        SymbolEntry *se = new IdentifierSymbolEntry($1, $2, identifiers->getLevel());
        identifiers->install($2, se);
        $$ = new DeclStmt(new Id(se));
    }
    ;

/* TODO: 定义其他可能的语法规则 */
%%

int yyerror(char const* message)
{
    std::cerr<<message<<std::endl;
    return -1;
}